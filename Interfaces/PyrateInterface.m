(* ::Package:: *)

(* ::Section:: *)
(*Data*)


PyrateInterfaceVersion = "0.1";
PyrateInterfaceDate = "09 Feb 2017";
PyrateInterfaceAuthor  = "Benjamin Fuks";
PyrateInterfaceInstitute = "LPTHE - CNRS - UPMC";
PyrateInterfaceReference = "Fuks & Lyonnet, arXiv:170M.NNNNN";


$PyrateInferfaceDebug=False;


PyrateRep[1]=1;


(* ::Section::Closed:: *)
(*ESignature*)


PyrateInterfaceBlank[]:=Print["***                                                  ***"];
PyrateInterfaceFull[]:=Print["**********************************************************"];


PyrateInterfaceSignature[]:=Block[{},
  PyrateInterfaceFull[]
  Print["***    Welcome to the FeynRules-Pyr@te interface     ***"];
  PyrateInterfaceBlank[];
  Print["***    Version: " <> PyrateInterfaceVersion <> "            Date: " <> PyrateInterfaceDate <> "     ***"]; 
  Print["***    Author: " <> PyrateInterfaceAuthor <> " (" <> PyrateInterfaceInstitute <> ")   ***"];
  PyrateInterfaceBlank[];
  Print["***    Please cite: " <> PyrateInterfaceReference <> " ***"];
  PyrateInterfaceBlank[];
  PyrateInterfaceFull[]
];


PyrateInterfaceFooter[]:=Block[{},
  PyrateInterfaceFull[];
  PyrateInterfaceBlank[];
  Print["***  Thanks for using the FeynRules-Pyr@te interface ***"];
  PyrateInterfaceBlank[];
  PyrateInterfaceFull[];
];


(* ::Section::Closed:: *)
(*Logger*)


PyrateInterfaceMsg[message_]:=Print[Style["***      "<>message,Blue]];
PyrateInterfaceInfo[message_]:=Print[Style["*** INFO: "<>message,Blue]];
PyrateInterfaceWarning[message_]:=Print[Style["*** WARNING: "<>message,Magenta,Bold]];
PyrateInterfaceDebug[message_]:=If[$PyrateInferfaceDebug,Print[Style["*** DEBUG: "<>message,Orange,Bold]]];
PyrateInterfaceError[message_]:=Print[Style["*** ERROR: "<>message,Red,Bold]];


(* ::Section::Closed:: *)
(*Header of the Pyr@te model file*)


(* ::Text:: *)
(*Advertisement on FeynRules*)


PyrateInterfaceWriteHeader[stream_]:=Block[{},
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream,"#                                                 #\n"];
  WriteString[stream,"# Pyr@te model file generated by FeynRules " <>FR$VersionNumber <>" #\n"];
  WriteString[stream,"# Interface version " <> PyrateInterfaceVersion <> "                           #\n"];
  WriteString[stream,"# Interface author: " <> PyrateInterfaceAuthor <> "                 #\n"];
  WriteString[stream,"#                                                 #\n"];
  WriteString[stream,"# ############################################### #\n\n"];
  WriteString[stream,"---\n\n"];
];


(* ::Text:: *)
(*Model information*)


PyrateInterfaceWriteModelInfo[stream_]:=Block[{},
  WriteString[stream,"Author:   "<>StringDrop[StringJoin@@(#<>", "&/@(Authors/.M$Information)),-2]<>"\n"];
  WriteString[stream,"Date:     "<>ToString[Date/.M$Information]<>"\n"];
  WriteString[stream,"Name:     "<>StringReplace[M$ModelName," "->"_"]<>"\n"];
  WriteString[stream,"Groups:   "<>ToString["'"<>ToString[#]<>"':"<>PyrateTag[#]&/@MR$GaugeGroupList]<>"\n\n"];
];  


(* ::Section:: *)
(*Fields*)


(* ::Subsubsection:: *)
(*Fermions*)


PyrateInterfaceWriteFermions[stream_,fermlist_]:=Block[{gaugeindices, pygroupinfo,fermioninfo={}},
  (* Gauge group information *)
  gaugeindices=Flatten[DeleteCases[Representations/.MR$GaugeGroupRules[#]&/@MR$GaugeGroupList,Representations],1][[All,2]];
  pygroupinfo = {#,PyrateTag[#],Representations/.MR$GaugeGroupRules[#]/.Representations->(Charge/.MR$GaugeGroupRules[#])}&/@MR$GaugeGroupList;

  (* Computing the fermionic information *)
  Block[{ngen,myferm=#,myrepr},
    (* Number of generations *)
    ngen=Select[$IndList[myferm]/.Index->Sequence,!MemberQ[Union[gaugeindices,{Spin,Lorentz}],#]&]/.{{}->1,{a_}:>Length[IndexRange[Index[a]]]};

    (* Representations *)
    myrepr = If[#[[2]]==="U1",{#[[1]],InputForm[#[[3]][myferm]]},{#[[1]],PyrateRep[Intersection[$IndList[myferm]/.Index->Sequence,#[[3]][[All,2]]]/.{{a_}->a,{}->1}]}]&/@pygroupinfo;

    (* Checking whether the fermion or the natifermkion must be used *)
    If[MemberQ[fermlist,anti[myferm]], 
      myrepr=If[#[[2]]==="U1",{#[[1]],InputForm[-#[[3]][myferm]]},{#[[1]],-PyrateRep[Intersection[$IndList[myferm]/.Index->Sequence,#[[3]][[All,2]]]/.{{a_}->a,{}->1}]/.-1->1}]&/@pygroupinfo;
      myferm=anti[myferm];
    ];

    (* Formatting *)
    myrepr=(ToString[#[[1]]]<>": "<>ToString[#[[2]]])&/@myrepr;
    fermioninfo=Append[fermioninfo, "  "<>StringReplace[ToString[myferm],"bar"->"*"]<>" : { Gen: " <> ToString[ngen] <> ", Qnb: "<>ToString[myrepr]<>"},\n"];
  ]&/@ Cases[{ClassName,GaugeField}/.MR$ClassesRules[#]&/@ Cases[MR$ClassesList,F[_]],{_,True}][[All,1]];

  (* Printout *)
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream,"# Weyl fermions                                   #\n"];
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream, "Fermions: {\n"];
  WriteString[stream, #]&/@fermioninfo;
  WriteString[stream, "}\n\n"];
];  


(* ::Subsubsection::Closed:: *)
(*Real scalars*)


PyrateInterfaceWriteRealScalars[stream_]:=Block[{gaugeindices, pygroupinfo,scalarinfo={}},
  (* Gauge group information *)
  gaugeindices=Flatten[DeleteCases[Representations/.MR$GaugeGroupRules[#]&/@MR$GaugeGroupList,Representations],1][[All,2]];
  pygroupinfo = {#,PyrateTag[#],Representations/.MR$GaugeGroupRules[#]/.Representations->(Charge/.MR$GaugeGroupRules[#])}&/@MR$GaugeGroupList;

  (* Computing the fermionic information *)
  Block[{ngen,myscal=#,myrepr},
    ngen=Select[$IndList[myscal]/.Index->Sequence,!MemberQ[Union[gaugeindices,{Spin,Lorentz}],#]&]/.{{}->1,{a_}:>Length[IndexRange[Index[a]]]};
    myrepr = If[#[[2]]==="U1",{#[[1]],InputForm[#[[3]][myscal]]},{#[[1]],PyrateRep[Intersection[$IndList[myscal]/.Index->Sequence,#[[3]][[All,2]]]/.{{a_}->a,{}->1}]}]&/@pygroupinfo;
    myrepr=(ToString[#[[1]]]<>": "<>ToString[#[[2]]])&/@myrepr;
    If[ngen>1, PyrateInterfaceError["Real scalar fields cannot carry any generation index. Aborting!"]; Abort[]];
    scalarinfo=Append[scalarinfo, "  "<>ToString[myscal]<>" : " <> ToString[myrepr]<>",\n"];
 ]&/@ Select[Cases[{ClassName,GaugeField}/.MR$ClassesRules[#]&/@ Cases[MR$ClassesList,S[_]],{_,True}][[All,1]],SelfConjugateQ[#]&];

  (* Printout *)
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream,"# Real scalars                                    #\n"];
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream, "RealScalars: {\n"];
  WriteString[stream, #]&/@scalarinfo;
  WriteString[stream, "}\n\n"];
];  


(* ::Subsubsection::Closed:: *)
(*Complex scalars*)


PyrateInterfaceWriteComplexScalars[stream_]:=Block[{gaugeindices, pygroupinfo,scalarinfo={}},
  (* Gauge group information *)
  gaugeindices=Flatten[DeleteCases[Representations/.MR$GaugeGroupRules[#]&/@MR$GaugeGroupList,Representations],1][[All,2]];
  pygroupinfo = {#,PyrateTag[#],Representations/.MR$GaugeGroupRules[#]/.Representations->(Charge/.MR$GaugeGroupRules[#])}&/@MR$GaugeGroupList;

  (* Computing the fermionic information and formatting *)
  Block[{ngen,myscal=#,myrepr,myreprbar, scname},
    ngen=Select[$IndList[myscal]/.Index->Sequence,!MemberQ[Union[gaugeindices,{Spin,Lorentz}],#]&]/.{{}->1,{a_}:>Length[IndexRange[Index[a]]]};
    myrepr = If[#[[2]]==="U1",{#[[1]],InputForm[#[[3]][myscal]]},{#[[1]],PyrateRep[Intersection[$IndList[myscal]/.Index->Sequence,#[[3]][[All,2]]]/.{{a_}->a,{}->1}]}]&/@pygroupinfo;
    myrepr=(ToString[#[[1]]]<>": "<>ToString[#[[2]]])&/@myrepr;
    myreprbar = If[#[[2]]==="U1",{#[[1]],InputForm[-#[[3]][myscal]]},{#[[1]],-PyrateRep[Intersection[$IndList[myscal]/.Index->Sequence,#[[3]][[All,2]]]/.{{a_}->a,{}->1}]/.-1->1}]&/@pygroupinfo;
    myreprbar=(ToString[#[[1]]]<>": "<>ToString[#[[2]]])&/@myreprbar;
    If[ngen>1, PyrateInterfaceError["Complex scalar fields cannot carry any generation index. Aborting!"]; Abort[]];
    scname=StringReplace[ToString[myscal],"I"->"i"];
    scalarinfo=Append[scalarinfo, "  "<>scname<>"  : { RealFields: [" <> scname <> "r,  I*" <> scname <> "i], Norm: 1/Sqrt(2), Qnb: "<> ToString[myrepr]<>"},\n"];
    scalarinfo=Append[scalarinfo, "  "<>scname<>"* : { RealFields: [" <> scname <> "r, -I*" <> scname <> "i], Norm: 1/Sqrt(2), Qnb: "<> ToString[myreprbar]<>"},\n"];
 ]&/@ Select[Cases[{ClassName,GaugeField}/.MR$ClassesRules[#]&/@ Cases[MR$ClassesList,S[_]],{_,True}][[All,1]],!SelfConjugateQ[#]&];

  (* Printout *)
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream,"# Complex scalars                                 #\n"];
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream, "CplxScalars: {\n"];
  WriteString[stream, #]&/@scalarinfo;
  WriteString[stream, "}\n\n"];
];  


(* ::Section:: *)
(*Potential*)


(* ::Subsubsection:: *)
(*Quartic terms*)


PyrateInterfaceWritePotentialQuartic[stream_,Lag_]:=Block[{terms,indexinfo,GetGName},
  (* From a representation to the name of the group *)
  indexinfo={#[[1]],#[[2,All,2]]}&/@DeleteCases[{#,Representations}/.MR$GaugeGroupRules[#]&/@MR$GaugeGroupList,{_,Representations}];
  GetGName[indx_]:=Select[indexinfo,MemberQ[#[[2]],indx]&][[1,1]];

  (* Computing the information *)
  terms=If[Head[Lag]===Plus,List@@Lag,{Lag}];
  terms = {
    Abs[#/.{_?(FieldQ[#]===True&)[__]->1,_?(FieldQ[#]===True&)->1}]/.Abs->Sequence, 
    List@@(#/.{_?(numQ[#]===True&)[__]->1,_?(numQ[#]===True&)->1})/.fi_?(FieldQ[#]===True&)[__]->fi,
    ToString/@GetGName/@Flatten[Union[$IndList/@(List@@(#/.{_?(numQ[#]===True&)[__]->1,_?(numQ[#]===True&)->1})/.fi_?(FieldQ[#]===True&)[__]->fi)/.Index->Sequence]]
  }&/@terms;

  PyrateInterfaceError["      !! Here comes the CGC calculations !!"];

  (* Formatting *)
  terms = ("    '"<>ToString[#[[1]]/._?NumericQ->1]<>"' : {Fields : "<> StringReplace[ToString[(StringReplace[ToString[InputForm[#]],"bar"->"*"]&/@#[[2]])],{"{"->"[","}"->"]"}]<>", Norm : " <>
    ToString[InputForm[#[[1]]/(#[[1]]/._?NumericQ->1)]]<>", CGCs : "<>ToString[#<>" : [2]"&/@#[[3]]]<>"},\n")&/@terms;

  (* Printout *)
  WriteString[stream, "  QuarticTerms: {\n"];
  WriteString[stream, #]&/@terms;
  WriteString[stream, "  },\n\n"];
];


(* ::Subsubsection::Closed:: *)
(*Quadratic terms*)


PyrateInterfaceWritePotentialQuadratic[stream_,Lag_]:=Block[{terms},
  (* Computing the information *)
  terms=If[Head[Lag]===Plus,List@@Lag,{Lag}];
  terms = {
    Abs[#/.{_?(FieldQ[#]===True&)[__]->1,_?(FieldQ[#]===True&)->1}]/.Abs->Sequence, 
    List@@(#/.{_?(numQ[#]===True&)[__]->1,_?(numQ[#]===True&)->1})/.fi_?(FieldQ[#]===True&)[__]->fi
  }&/@terms;

  (* Formatting *)
  terms = ("    '"<>ToString[#[[1]]/.{Power[a_,2]:>Symbol[ToString[a]<>"Pow2"],_?NumericQ->1}]<>"' : {Fields : "<> StringReplace[ToString[(StringReplace[ToString[InputForm[#]],"bar"->"*"]&/@#[[2]])],{"{"->"[","}"->"]"}]<>", Norm : " <>
    ToString[InputForm[(#[[1]]/.Power[a_,2]:>a)/(#[[1]]/._?NumericQ->1)]]<>"},\n")&/@terms;

  (* Printout *)
  WriteString[stream, "  ScalarMasses: {\n"];
  WriteString[stream, #]&/@terms;
  WriteString[stream, "  },\n\n"];
];


(* ::Subsubsection:: *)
(*Yukawa terms*)


PyrateInterfaceWritePotentialYukawas[stream_,Lag_]:=Block[{terms,Pr},
  (* Computing the information *)
  terms=If[Head[Lag]===Plus,List@@Lag,{Lag}];
  terms = {
    Abs[#/.Dot->Times/.{_?(FieldQ[#]===True&)[__]->1,_?(FieldQ[#]===True&)->1}]/.Abs->Sequence/.{a_?(MemberQ[M$Parameters[[All,1]],#]&)[i1_,i2_]:>a,Eps[__]->1}, 
    List@@(#/.Dot->Times/.{_?(numQ[#]===True&)[__]->1,_?(numQ[#]===True&)->1})/.fi_?(FieldQ[#]===True&)[__]->fi
  }&/@terms;

  (* Formatting *)
  terms = ("    '"<>ToString[#[[1]]/._?NumericQ->1]<>"' : {Fields : "<> StringReplace[ToString[(StringReplace[ToString[InputForm[#]],"bar"->"*"]&/@#[[2]])],{"{"->"[","}"->"]"}]<>", Norm : " <>
    ToString[InputForm[#[[1]]/(#[[1]]/._?NumericQ->1)]]<>"},\n")&/@terms;

  (* Printout *)
  WriteString[stream, "  Yukawas: {\n"];
  WriteString[stream, #]&/@terms;
  WriteString[stream, "  },\n\n"];
];


(* ::Section:: *)
(*Core function*)


Options[WritePyrateOutput]={Output->Default};


WritePyrateOutput[lagr_, OptionsPattern[]]:=Block[{fname,stream,LScalar,LScalarMasses,LQuarticScalars,LYukawas,YukTerms,FermionList={}},
  (* Electronic signature *)
  PyrateInterfaceSignature[];
 
  (* setup *)
  fname=StringReplace[(OptionValue[Output]/.Default->ToString[M$ModelName]<>"_PYRATE")<>".model"," "->"_"];
  If[FileExistsQ[fname], PyrateInterfaceWarning["Previous Pyr@te model file found -> superseding..."]];
  PyrateInterfaceInfo["The Pyr@te model file will be located at: "];
  PyrateInterfaceMsg["  "<> Directory[]<>"/"<>fname];
  stream = OpenWrite[fname];

  (* Calculations *)
  LScalar = Expand[lagr/.{_?(FermionQ[#]===True&)[__]->0,_?(FermionQ[#]===True&)->0,_?(VectorFieldQ[#]===True&)[__]->0,_?(GhostFieldQ[#]===True&)[__]->0,_?(GhostFieldQ[#]===True&)->0,del[__]->0}];
  LScalarMasses=Select[LScalar,Length[GetFieldContent[#]]==2&];
  LQuarticScalars=Select[LScalar,Length[GetFieldContent[#]]==4&];
  LYukawas = Select[Expand[lagr/.{_?(VectorFieldQ[#]===True&)[__]->0,_?(GhostFieldQ[#]===True&)[__]->0,_?(GhostFieldQ[#]===True&)->0,del[__]->0}],Or@@(FermionQ[#]===True&/@(List@@#/.Dot->Sequence))&]/.Conjugate[_]->0;

  (* Selecting the fermion fields appearing in the Yukawa *)
  YukTerms = If[Head[LYukawas]===Plus,List@@LYukawas,{LYukawas}];
  LYukawas = Plus@@(Block[{fields,yuk,Cyuk,inter, Cinter,resu},
    fields=DeleteCases[List@@#/.Dot->Sequence,_?(FieldQ[#]=!=True&)]/.a_?(FieldQ[#]===True&)[__]->a;
    yuk=Select[fields,FermionQ[#]===True&];
    Cyuk=anti/@Select[fields,FermionQ[#]===True&];
    inter=Intersection[FermionList,yuk];
    Cinter=Intersection[FermionList,Cyuk];

    If[inter=!={} &&Cinter=!={}, PyrateInterfaceError["Cannot find a unique set of fermion fields defining the Yukawas"];Abort[]];
    If[inter=!={} &&Cinter==={}, FermionList=Flatten[Union[FermionList,yuk]]; resu=#];
    If[Cinter=!={} &&inter==={}, FermionList=Flatten[Union[FermionList,Cyuk]]; resu=HC[#]];
    If[inter==={} &&Cinter==={}, FermionList=Flatten[Union[FermionList,yuk]]; resu=#];
  resu]&/@YukTerms);

  (* E-signature and information *)
  PyrateInterfaceWriteHeader[stream];
  PyrateInterfaceDebug["Writing model information"];
  PyrateInterfaceWriteModelInfo[stream];

  (* Fields *)
  PyrateInterfaceDebug["Treating fermions"]; PyrateInterfaceWriteFermions[stream,FermionList];
  PyrateInterfaceDebug["Treating real scalars"]; PyrateInterfaceWriteRealScalars[stream];
  PyrateInterfaceDebug["Treating complex scalars"]; PyrateInterfaceWriteComplexScalars[stream];

 (* Potential *)
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream,"# Potential                                       #\n"];
  WriteString[stream,"# ############################################### #\n"];
  WriteString[stream, "Potential: {\n\n"];
  PyrateInterfaceDebug["  > quartic terms"];   PyrateInterfaceWritePotentialQuartic[stream,LQuarticScalars];
  PyrateInterfaceDebug["  > quadratic terms"]; PyrateInterfaceWritePotentialQuadratic[stream,LScalarMasses];
  PyrateInterfaceDebug["  > Yukawa terms"];    PyrateInterfaceWritePotentialYukawas[stream,LYukawas];
  WriteString[stream, "}\n\n"];

  (* Exit *)
  Close[stream];
  PyrateInterfaceFooter[];
];
